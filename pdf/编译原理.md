## 龙书

### 8 代码生成

**指令选择** 

IR->指令的映射，知道指令的代价很重要，但有时很难获得

**寄存器**

寄存器分配  某个程序点，选择一组变量放在寄存器中

寄存器指派 指定变量存放在哪个寄存器

**代价**

目标不同由：编译/运行时间，代码大小，能耗等

**基于DAG的基本块内优化**

为基本块内指令构建DAG->优化->转换为新的基本块

**活跃**

i: x = 1 def

i+1: z=2

j: y=x+1 use 

k: x = 2 def 

x在j处活跃，反向扫描基本块，在use点活跃在def点被杀死 def->use之间为一个活跃区间,

x=1的活跃区间为[i,j],x=2的def 杀死了x=1的活跃

**简单的代码生成器**

reg desc 记录哪些变量值存放在此寄存器

addr desc 记录变量当前值存储在哪些位置,reg,地址，栈位置等

### 10 指令级并行性

**数据依赖**

写后读是真依赖，读需要写的数据

其它依赖不是真依赖，本质是一种资源冲突，可以考虑使用不同的reg解决

**基本块指令调度**

数据依赖图->带优先级拓扑排序

**软件流水线**

挖掘连续迭代间的并行性，交叠多个循环的迭代

根据数据依赖和资源约束可以计算一个启动间隔T，根据T，调度指令

### 11 并行性和局部性优化

数值应用的循环下标和数据访问经常呈现仿射关系，c0+c1x1+c2x2+.... ，n层嵌套loop是一个n dim 的多面体

目标 给一个调度方案将相近的内存访问运算安排在靠近，且多核下尽量安排在相同核上

仿射分划 分划迭代多面体为不同部分，在不同核上执行，以仿射访问的方式对数组操作，没有指针操作，分析相对容易

分块 将太大的数组/矩阵，分块计算在内循环中保证更好的访存局部性

使用affine分析循环中数组内存访问模式，分析依赖关系更好的分划、分块，调度循环
